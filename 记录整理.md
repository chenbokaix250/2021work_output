# LaneProject

理解代码中途的一些知识点记录整理

### memcpy()函数

`void memcpy(void str1,const void str2,size_t n) `
从存储区str2复制n个字节到存储区str1


### Mat的创建
`cv::Mat img(2,2,CV_8U3,cv::Scalar(0,0,255)`
创建了一个2行2列的矩阵,矩阵元素使用8位无符号char类型保存,具有3通道,每个像素的初始值是(0,0,255)


### 带参数的构造函数

构造函数可以带有参数.在创建对象时就会给对象赋初始值.
```c
#include <iostream>
using namespace std;

class Line
{
public:
    void setLength(double len);
    double getLength(void);
    Line(double len);//构造函数

private:
    double length;
};

//成员函数定义,包括构造函数
Line::Line(double len)
{
    cout<"Object is being created,length = "<<len<<endl;
    length = len;
}

int main()
{
    Line line(10,0);

    return 0;
}

```


### OpenCV积分图函数:integral()详解

`void integral(InputArray src,OutputArray sum,OutputArray sqsum,int sdepth = -1,int sqdepth = -1);`
* 输入图像
* 和表
* 平方和表
* 和表深度 CV_32S
* 平方和表深度 CV_32F

### C++绝对值函数
```c
int abs(int i);//整数绝对值
double cabs(struct complex znum); //返回复数znum的绝对值
double fabs(double x);//返回双精度参数x的绝对值
long labs(long n);//返回长整型参数n的绝对值
```

### ioctl()函数介绍

一个字符设备驱动通常会实现常规的打开、关闭、读、写等功能，但在一些细分的情境下，如果需要扩展新的功能，通常以增设ioctl()命令的方式实现，其作用类似于“拾遗补漏”。在文件I/O中，ioctl扮演着重要角色，本文将以驱动开发为侧重点，从用户空间到内核空间纵向分析ioctl函数。
```c
#include <sys/ioctl.h> 

int ioctl(int fd, int cmd, ...) ;
```

fd:  文件描述符
cmd: 交互协议，设备驱动将根据cmd执行对应操作


### opencv提供函数reman()实现重映射
```c
void cv::remap(InputArray src,
               OutputArray dst,
               InputArray map1,
               InputArray map2,
               int interpolation,
               int borderMode = BORDER_CONSTANT,
               const Scalar & borderValue = Scalar()
               )
```

* src 输入图像
* dst 目标图像
* map1:(x,y)的第一个映射或者是CV_16SC2,CV_32FC1或CV_32FC2的值.
* map2: 第二个map，表示类型为CV_16UC1、CV_32FC1的y值或空值
* borderMode: 边界模式，有默认值BORDER_CONSTANT
* borderValue: 当有常数边界时使用的值，有默认值Scalar()即0


### gettimeofday()函数

gettimeofday()函数用于获取当前时间

```c
timeval 结构定义为：
struct timeval{
    long tv_sec;  //秒
    long tv_usec;  //微秒
};

timezone 结构定义为：
struct timezone
{
    int tz_minuteswest;  //和Greenwich 时间差了多少分钟
    int tz_dsttime;  //日光节约时间的状态
};

//范例

#include <sys/time.h>
#include <unistd.h>
main(){
    struct timeval tv;
    struct timezone tz;
    gettimeofday (&tv, &tz);
    printf("tv_sec; %d\n", tv.tv_sec);
    printf("tv_usec; %d\n", tv.tv_usec);
    printf("tz_minuteswest; %d\n", tz.tz_minuteswest);
    printf("tz_dsttime, %d\n", tz.tz_dsttime);
}

//tv_sec: 974857339
//tv_usec:136996
//tz_minuteswest:-540
//tz_dsttime:0
```

### munmap()函数

munmap()用来取消参数start 所指的映射内存起始地址，参数length 则是欲取消的内存大小。当进程结束或利用exec 相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。

返回值：如果解除映射成功则返回0，否则返回－1。错误原因存于errno 中错误代码EINVAL参数 start 或length 不合法。

### mmap()函数

`void * mmap(void *start, size_t length, int prot , int flags, int fd, offset)`
* start：要映射到的内存区域的起始地址，通常都是用NULL（NULL即为0）。NULL表示由内核来指定该内存地址
* length：要映射的内存区域的大小.
* prot：期望的内存保护标志，不能与文件的打开模式冲突。
* flags：指定映射对象的类型，映射选项和映射页是否可以共享。
* offset：表示被映射对象（即文件）从那里开始对映，通常都是用0.

### memset函数

memset() 函数可以是初始化内存的“万能函数”
```c
# include <string.h>
void *memset(void *s, int c, unsigned long n);
```
函数的功能是：将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换，注意 c 是 int 型。s 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。

### OpenCV中Mat::rowRange函数
```c
C++: Mat Mat::rowRange(int startrow, int endrow) const
C++: Mat Mat::rowRange(const Range& r) const

```
Mat的rowRange和colRange函数可以获取某些范围内行或列的指针


np.r_是按行连接两个矩阵，就是把两矩阵上下相加，要求列数相等，类似于pandas中的concat()

np.c_是按列连接两个矩阵，就是把两矩阵左右相加，要求行数相等，类似于pandas中的merge()



























